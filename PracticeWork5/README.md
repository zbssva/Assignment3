Проект содержит:

Стек (LIFO) — добавление и удаление элементов с вершины стека.

Очередь (FIFO) — добавление элементов в конец и извлечение из начала.

Тестирование параллельной работы потоков.


Что изучается:

Как использовать атомарные операции (atomicAdd, atomicSub) для безопасного доступа потоков к данным.

Как работает глобальная и разделяемая память CUDA.

Как синхронизация потоков влияет на корректность и производительность.

Как измерять результаты и проверять корректность параллельных структур.



Файлы проекта

parallel_structures.cu — основной код, где реализованы стек, очередь и CUDA-ядра.

Как запустить

Скомпилировать проект:

nvcc parallel_structures.cu -o parallel_structures


Запустить:

./parallel_structures

Как работает код

Выделяется память на GPU для данных стека и очереди, а также для массива результатов.

Инициализируются структуры Stack и Queue на GPU.

Запускаются CUDA-ядра:

Каждый поток пытается выполнить push/pop (для стека) или enqueue/dequeue (для очереди).

Атомарные операции гарантируют, что каждый поток безопасно работает с общей памятью.

Синхронизация потоков через cudaDeviceSynchronize() гарантирует завершение всех операций перед чтением результатов.

Результаты копируются на CPU и выводятся на экран.

Память GPU освобождается.

Пример вывода результатов
Стек (LIFO)
Stack results:
255 254 253 252 ... 0
Последние добавленные элементы извлекаются первыми.

Очередь (FIFO)
Queue results:
0 1 2 3 ... 255
Первые добавленные элементы извлекаются первыми.

Вывод:

Параллельные структуры данных работают корректно, даже если множество потоков одновременно изменяют данные.

Атомарные операции предотвращают гонки данных.

Стек и очередь демонстрируют разные способы обработки данных: LIFO и FIFO.

Можно сравнивать производительность параллельных структур с последовательной реализацией на CPU.